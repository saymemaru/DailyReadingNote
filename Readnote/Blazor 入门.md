# Blazer入门

## 简介

Blazor 是基于 HTML、CSS 和 C# 的新式前端 Web 框架

### 优势

- 使用可重用组件快速生成 Web UI： 使用 Blazor 的灵活组件模型，可以轻松生成可重用组件。
- 一个开发堆栈（C#）：使用单个开发堆栈生成整个 Web 应用，并在客户端和服务器上共享常见逻辑的代码。
- 与 JavaScript 的互动： 使用 C# 代码中的 JavaScript 库和浏览器 API 生态系统。
- 与现有应用集成： 将 Blazor 组件与现有的 MVC、Razor Pages 或基于 JavaScript 的应用集成。
- Web、移动端和桌面端：Blazor 组件还可以用于构建本机移动应用和桌面应用。这些应用使用了一种称为 Blazor 混合的本机与 Web 技术相结合的方式。

### 有哪些服务器端和客户端的呈现方式？

#### 1. 静态服务器渲染（Static Server Rendering SSR）

方法：

类似于传统的 ASP.NET Core Razor Pages 或 PHP，服务器生成初始 HTML 后发送给客户端。

优点：

- 极快的初始加载速度： 因为返回的是纯 HTML，无需下载大型运行时或建立 WebSocket 连接。对用户可见的内容（FCP/LCP）立即呈现。

- 卓越的 SEO 支持： 搜索引擎爬虫可以直接获取到完整的、已渲染的 HTML 内容，无需执行 JavaScript。

- 客户端资源消耗极低： 浏览器只需解析 HTML 和 CSS，无需运行复杂的 .NET 代码，非常适合低功耗设备。

- 无需 .NET 运行时在客户端： 客户端不需要支持 WebAssembly 或 .NET。

缺点：

- 无交互性： 这是最大的限制。按钮点击、表单输入等所有交互都需要整页回发（Postback），导致页面刷新，体验差。

- 无法保持状态： 每次请求都是全新的组件实例，无法维持之前的状态（除非通过 URL 参数或表单数据传递）。

适用场景：

- 静态内容网站： 博客、新闻文章、产品介绍页、公司官网等，这些页面主要目的是展示信息，而非复杂交互。

- 对 SEO 要求极高的公开页面： 例如，电商网站的商品列表页和详情页的初始渲染。

- 大型应用程序中的“壳”或布局： 使用静态渲染来快速显示导航栏、页脚等静态部分，然后在其中嵌入交互式组件。

#### 2. 交互式服务器渲染（Interactive Server Rendering ISR）

提供了丰富的交互体验，同时逻辑仍在服务器端。

优点：

- 丰富的交互性： 支持所有复杂的 UI 交互，如实时验证、复杂表单、拖拽等，且无需整页刷新，体验流畅。

- 初始下载小： 客户端只需下载少量 JavaScript 文件来建立 SignalR 连接，无需下载整个应用和 .NET 运行时。首次加载更快。

- 完全访问服务器资源： 组件代码在服务器上运行，可以安全、直接地访问数据库、内部网络、文件系统等服务器资源。

- 兼容性好：能在旧版浏览器（如 IE11，需额外配置）上运行。

缺点：

- 更高的服务器延迟和负载： 每个用户交互都需要一次网络往返。高延迟网络下，用户体验会明显下降。每个活跃用户都会在服务器上占用内存和 CPU 资源，可伸缩性是一个需要考虑的问题。

- 需要持续的网络连接： 如果 SignalR 连接断开（例如网络不稳定），应用将立即变得无响应，直到连接恢复。

- 可伸缩性挑战： 在用户量极大时，需要设计良好的扩展策略（如使用粘性会话）来管理服务器内存和连接状态。

适用场景：

- 企业内部应用（Line-of-Business）： 如 CRM、ERP、数据管理系统。这类应用通常运行在高速、稳定的内网中，用户数量相对可控，且需要深度集成服务器端功能。

- 对初始加载速度有要求，但又需要高交互性的应用。

#### 3. 交互式客户端渲染（WebAssembly WASM）

真正的 SPA（单页应用）模式，应用在浏览器中完全自主运行。

优点：

- 真正的客户端应用： 一旦下载完成，所有 UI 交互都在本地处理，响应速度极快，没有网络延迟。

- 离线支持： 与 Service Worker 结合，可以构建功能强大的离线应用（PWA）。

- 服务器压力小： 应用运行在客户端，服务器只需提供静态文件（.dll, .wasm）和 API 接口，后端服务器可以是无状态的，更容易水平扩展。

缺点：

- 首次加载慢： 最大的痛点。首次访问时需要下载 .NET 运行时和整个应用的程序集，这可能达到几兆字节，导致白屏时间较长。

- 浏览器兼容性要求： 需要浏览器支持 WebAssembly。

- 受限的客户端资源访问： 应用运行在浏览器的沙箱中，无法直接访问服务器端的数据库、文件系统等。

适用场景：

- 面向公众的、交互复杂的 SPA： 如在线设计工具、地图应用、复杂的仪表盘等，这些应用需要持续的、低延迟的交互。

- 离线应用/PWA： 如野外数据采集应用、移动端需要离线使用的工具。

## Blazer 应用

### 有哪些项目文件？

- Program.cs 是启动服务器和配置应用服务和中间件的应用的入口点。
- App.razor 是应用的根组件。
- Routes.razor 配置 Blazor 路由器。
- Components/Pages 目录包含应用的一些示例网页。
- BlazorApp.csproj 定义应用项目及其依赖项，可以通过双击解决方案资源管理器中的项目节点来查看。
- 属性目录中的 launchSettings.json 文件为本地开发环境定义不同的配置文件设置。 在创建项目时自动分配端口号，并将其保存在此文件上。

### 什么是 Razor 组件

Razor 是基于 HTML 和 C# 的标记语法。 Razor 文件 （.razor） 包含纯 HTML，然后包含 C# 来定义任何呈现逻辑，例如条件、控制流和表达式计算。 然后，Razor 文件编译为封装组件呈现逻辑的 C# 类。  
在 Blazor 中，Razor 文件定义构成应用 UI 部分的可重用组件。 组件定义要呈现的 HTML 以及如何处理用户事件。

在编译时，每个 Razor 组件都内置在 C# 类中。 该类可以包含常见的 UI 元素，例如状态、呈现逻辑、生命周期方法和事件处理程序。  
由于在 Razor 中创建的 Blazor 组件只是 C# 类，因此可以使用组件的任意 .NET 代码。

#### Razor语法

[Razor语法](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-9.0)

Razor 支持 C#，并使用 @ 符号从 HTML 转换为 C#。否则会转换为纯 HTML。

``@page`` 
>指令指定页面路径

``@rendermode="InteractiveServer"``  
``<... @rendermode="InteractiveServer" />``
>指定页面/组件渲染方式

``@code`` 
>用于将 C# 类成员（字段、属性和方法）添加到组件。  
>可以跟踪组件状态，添加组件参数，实现组件生命周期事件，并定义事件处理程序

#### 显式 Razor 表达式

``@(C#表达式)`` 
>显式 Razor 表达式由 `@` 符号和 `()` 圆括号组成  
>将计算 @() 括号中的所有内容，并将其呈现到输出中。

``@("<span>Hello World</span>")``
>计算结果为 IHtmlContent 的 C# 表达式直接通过 IHtmlContent.WriteTo 呈现

#### Razor 代码块

``@{}``
>Razor 代码块以 `@` 开始，并括在 `{}` 中。 代码块内的 C# 代码不会呈现。 一个视图中的代码块和表达式共享相同的作用域并按顺序进行定义

#### 添加组件

``[Parameter]`` 
>添加在``@code``中的 C# 成员上方，来标记为组件参数

``<组件名 />`` 
>将组件添加到页面中

``<组件名 参数= 值 />`` 
>为组件添加参数

#### 添加控制流

`@if` `@foreach` `@using{}` `@try` 
`@lock`
>添加`@`字符，将 C# 控制流呈现在 Razor

#### 注释

```C#
@{
    /* C# comment */
    // Another C# comment
}
```
>在呈现网页之前，服务器会删除 Razor 注释

#### 处理事件

``@事件名="() => {C#表达式}"``  
``@事件名="C#方法"`` 
>使用为 HTML 事件指定 C# 事件处理程序

```c#
void InputChanged(ChangeEventArgs e){
    message = (string)e.Value;}
```

>事件处理程序方法可以选择采用包含事件相关信息的事件参数

#### 数据绑定

``@bind="特定值"``
>将 UI 元素的值绑定到代码中的特定值  
当 UI 元素的值更改时，代码值应更改  
当代码值更改时，UI 元素应显示新值  





